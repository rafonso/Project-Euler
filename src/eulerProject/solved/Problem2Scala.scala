package eulerProject.solved

/**
 Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:<br>
<br>
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...<br>
<br>
Find the sum of all the even-valued terms in the sequence which do not exceed four million.
 */
object Problem2Scala {
  
  def getFibonacciSequenceUntilLimit(initial1: Int, initial2: Int, limit: Int): List[Int] = {
    
    def getFibonacciSequence(currentValue: Int, previousValue: Int, limit: Int): List[Int] = 
      if((currentValue + previousValue) > limit) Nil 
      else (currentValue + previousValue) :: getFibonacciSequence(currentValue + previousValue, currentValue, limit)
    
    initial1 :: initial2 :: getFibonacciSequence(initial1 + initial2, initial2, limit)
  }
  
  def sumIfEven(accumulated: Int, current: Int): Int = if(current % 2 == 0) accumulated + current else accumulated  
  
  def main(args : Array[String]) : Unit = {
    val initial1 = Integer.parseInt(args(0))
    val initial2 = Integer.parseInt(args(1))
    val size = Integer.parseInt(args(2))
    if(size <= 2) {
      throw new IllegalArgumentException("Size must be greater than 2")
    }
    
    val t0 = System.nanoTime
    val fibonacci = getFibonacciSequenceUntilLimit(initial1, initial2, size)
    println("Fibonacci(" + initial1 + ", " + initial2  + ", " + size + ") = " + fibonacci)
    val sum = fibonacci.foldLeft(0)(sumIfEven(_, _))
    val deltaT = System.nanoTime - t0
    
    println("Sum of even Fibonacci(" + initial1 + ", " + initial2  + ", " + size + ") = " + sum)
    println("Time = " + deltaT + " ns")
  }
}
/*
  def getFibonacciSequence(a: Int, b: Int, limit: Int): List[Int] = limit match {
    case 0 => Nil
    case _ => (a + b) ::  
  }
  
  def getFibonacciSequence(initial1: BigInt, initial2: BigInt, size: Int): List[BigInt] = {
    
    def getFibonacciSequence(a: BigInt, b: BigInt, limit: Int): List[BigInt] = if(limit == 0) Nil else (a + b) :: getFibonacciSequence(b, a + b, limit - 1)
    
    initial1 :: initial2 :: getFibonacciSequence(initial1, initial2, size)
   }

 def getFibonacciEvenSumUntilLimit(initial1: Int, initial2: Int, limit: Int): Int = {
    
    def isEven(n: Int): Boolean = (n % 2 == 0)
    
    def getFibonacciSum(currentValue: Int, previousValue: Int, limit: Int): Int = {
      val nextValue = currentValue + previousValue
      if(nextValue > limit) {
        0
      } else if(isEven(nextValue)) {
        nextValue + getFibonacciSum(nextValue, currentValue, limit)
      } else {
        getFibonacciSum(nextValue, currentValue, limit)
      }
    } 
      
    var sum = 0
    if(isEven(initial1)) {
      sum += initial1
    }
    if(isEven(initial2)) {
      sum += initial2
    }
    
    sum + getFibonacciSum(initial1, initial2, limit) 
  }
  

 */